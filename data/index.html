<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kroner Hub - Display</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #ffffff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
    }
    
    .display-section {
      background: #ffffff;
      border-radius: 8px;
      padding: 60px 40px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
    }
    
    .display-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 40px;
    }
    
    .time-display {
      flex: 1;
      font-size: 120px;
      font-weight: 600;
      color: #202124;
      letter-spacing: 2px;
      font-variant-numeric: tabular-nums;
      font-family: 'Roboto Mono', monospace;
    }
    
    .points-display {
      flex: 0 0 auto;
      font-size: 100px;
      font-weight: 600;
      color: #202124;
      letter-spacing: 2px;
      font-family: 'Roboto Mono', monospace;
      min-width: 150px;
      text-align: right;
    }

    .messages-section {
      background: #ffffff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .messages-label {
      font-size: 14px;
      font-weight: 600;
      color: #5f6368;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .messages-container {
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e8eaed;
      height: 200px;
      overflow-y: auto;
      padding: 12px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }

    .message-item {
      padding: 8px;
      margin-bottom: 6px;
      background: white;
      border-left: 3px solid #1f2937;
      border-radius: 3px;
      line-height: 1.4;
    }

    .message-time {
      font-size: 11px;
      color: #9ca3af;
      margin-right: 8px;
    }

    .message-text {
      color: #202124;
    }

    .messages-container::-webkit-scrollbar {
      width: 6px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: #f8f9fa;
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="display-section">
      <div class="display-content">
        <div class="time-display" id="timeDisplay">--:--</div>
        <div class="points-display" id="pointsDisplay">--</div>
      </div>
    </div>

    <div class="messages-section">
      <div class="messages-label">Mensajes</div>
      <div class="messages-container" id="messagesContainer"></div>
    </div>
  </div>

  <script>
    let lastMessageId = 0;
    const MAX_MESSAGES = 50;
    let ws = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 3000; // 3 segundos
    
    /**
     * Decodifica el mensaje según el protocolo display.md
     * Formato: XXYYT F PPTEXT...
     */
    function decodeMessage(data) {
      // Ser tolerantes: si no cumple el largo, devolvemos lo que tengamos
      if (data.length < 6) {
        return { valid: false, raw: data };
      }

      const typeChar = data.substring(4, 5);
      const type = parseInt(typeChar);
      const points = data.length >= 8 ? data.substring(6, 8) : '';
      // Si falta PP, al menos intentamos usar el resto como texto
      const text = data.length >= 8 ? data.substring(8) : data.substring(5);

      return {
        valid: !Number.isNaN(type),
        type,
        points,
        text
      };
    }

    function updateDisplay(decoded) {
      const timeDisplay = document.getElementById('timeDisplay');
      const pointsDisplay = document.getElementById('pointsDisplay');

      if (decoded.type === 1) {
        // T=1: Crono con puntos
        timeDisplay.textContent = decoded.text || '--:--';
        pointsDisplay.textContent = decoded.points || '--';
      } else if (decoded.type === 2) {
        // T=2: Texto normal
        timeDisplay.textContent = decoded.text || '';
        pointsDisplay.textContent = '--';
      } else if (decoded.type === 3) {
        // T=3: Limpiar pantalla
        timeDisplay.textContent = '--:--';
        pointsDisplay.textContent = '--';
      } else if (decoded.type === 4) {
        // T=4: Texto con limpieza previa
        timeDisplay.textContent = decoded.text || '';
        pointsDisplay.textContent = '--';
      } else {
        // Otros tipos: mostrar texto y puntos si vienen
        timeDisplay.textContent = decoded.text || '--';
        pointsDisplay.textContent = decoded.points || '--';
      }
    }

    function addMessage(text) {
      const container = document.getElementById('messagesContainer');
      const now = new Date();
      const time = now.toLocaleTimeString();
      
      const msgItem = document.createElement('div');
      msgItem.className = 'message-item';
      msgItem.innerHTML = `<span class="message-time">${time}</span><span class="message-text">${text}</span>`;
      
      container.appendChild(msgItem);
      
      // Limitar a MAX_MESSAGES
      const items = container.querySelectorAll('.message-item');
      if (items.length > MAX_MESSAGES) {
        items[0].remove();
      }
      
      // Auto-scroll al final
      container.scrollTop = container.scrollHeight;
    }

    /**
     * Conecta al WebSocket del servidor
     */
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.hostname}:81/`;
      
      console.log('Conectando a WebSocket:', wsUrl);
      ws = new WebSocket(wsUrl);
      
      ws.onopen = function() {
        console.log('WebSocket conectado');
        reconnectAttempts = 0;
        addMessage('[Conectado al servidor]');
      };
      
      ws.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          
          if (data.len > 0 && data.time > lastMessageId) {
            lastMessageId = data.time;

            // Decodificar base64
            const binaryString = atob(data.data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }

            // Convertir a string
            let display = '';
            try {
              display = String.fromCharCode(...bytes);
            } catch (e) {
              display = '';
            }

            // Decodificar según protocolo
            const decoded = decodeMessage(display);
            // Siempre mostramos en el historial para depurar
            addMessage(display || '[vacío]');

            if (decoded.valid) {
              updateDisplay(decoded);
            }
          }
        } catch (error) {
          console.error('Error al procesar mensaje:', error);
        }
      };
      
      ws.onerror = function(error) {
        console.error('Error en WebSocket:', error);
        addMessage('[Error en WebSocket]');
      };
      
      ws.onclose = function() {
        console.log('WebSocket desconectado');
        addMessage('[Desconectado del servidor]');
        
        // Intentar reconectar
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          console.log(`Reintentando conexión (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
          setTimeout(connectWebSocket, RECONNECT_DELAY);
        } else {
          console.error('Máximo número de reintentos alcanzado');
          addMessage('[No se pudo reconectar]');
        }
      };
    }

    // Conectar al cargar la página
    connectWebSocket();
  </script>
</body>
</html>
